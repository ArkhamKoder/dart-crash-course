3/30/2023

 NOTES:

    In the analysis_options.yaml theres a linter rule to always specify types or camel case.

    Truncating divison ~/ rounds off to an interger

    Unary prefix operators (before value)
        print(--age);
        print(!true);
        print(++age);
        const variables can't be mutated in unary
        modified the value and returns the result 

    Unary bitwise completement prefix operator
        print(~1);

    Unary postfix operator(after value)
        returns the value first then modifies it
        print(age++);
        print(age--);

    Binary infix(inbetween values)
        age + age1
        age != age1
        age == age1
        age % age1
        Euclidean module(remainder) %

    Bitwise infix operators
        print(age & 20) // bitwise AND 
        print(age | 20) // bitwise OR
        print(age ^ 20) // bitwise XOR
        print(age << 20) // bitwise left shift
        print(age >> 20) // bitwsie right shift
    Compound assignment operators
        age = 20;
        print(age = 30) => 30
        print(age ~/= 2) => 15 (truncating division)
        print(age *= 2); // 30
        print(age += 2); // 32
        print(age &= 2); // 2

    Optionality?
        Is the ability for a variable to either contain a value of a particular data type or be null

        String? name  = null;
        name = "John";

        If no datatype is specified dart will treat the variable a dynamic datatype.

        Null aware compound assignment operator (??=)

            String? lastName;
            lastName ??= 'Bar';
            // Assign the value of the LHS to the variable only if the variable is nullable.

        Null Aware Operator (?)
            To access the properties of optional variables

            String? nullName;
            print(nullName ?? 'Foo'); // 'Foo'.

        Nullable Collections

            List<String>? names; // could either be null or contain a list of strings.

            List<String?>? names; // could be null or contain a list of nullable strings.

4/1/2023
	NOTES:

        Late Keyword (late)
            Late variables are initialized when they are first used
            ===============================
            void main(){
                print('Before');
                late String name = provideName();
                print('After');
                print('name')
            }

            String provideName(){
                print('Function is called');
                return 'Foo Bar'
            }

            Output:
            >> Before
            >> After
            >> Function is called
            >> Foo Bar
            ===============================

            Late final will be initialized when they are used and can not be reaasigned.

5/1/2023
	NOTES:

        Functions

        







	
	

            

