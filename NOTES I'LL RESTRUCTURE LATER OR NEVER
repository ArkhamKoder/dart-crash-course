3/30/2023

 NOTES:

    In the analysis_options.yaml theres a linter rule to always specify types or camel case.

    Truncating divison ~/ rounds off to an interger

    Unary prefix operators (before value)
        print(--age);
        print(!true);
        print(++age);
        const variables can't be mutated in unary
        modified the value and returns the result 

    Unary bitwise completement prefix operator
        print(~1);

    Unary postfix operator(after value)
        returns the value first then modifies it
        print(age++);
        print(age--);

    Binary infix(inbetween values)
        age + age1
        age != age1
        age == age1
        age % age1
        Euclidean module(remainder) %

    Bitwise infix operators
        print(age & 20) // bitwise AND 
        print(age | 20) // bitwise OR
        print(age ^ 20) // bitwise XOR
        print(age << 20) // bitwise left shift
        print(age >> 20) // bitwsie right shift
    Compound assignment operators
        age = 20;
        print(age = 30) => 30
        print(age ~/= 2) => 15 (truncating division)
        print(age *= 2); // 30
        print(age += 2); // 32
        print(age &= 2); // 2

    Optionality?
        Is the ability for a variable to either contain a value of a particular data type or be null

        String? name  = null;
        name = "John";

        If no datatype is specified dart will treat the variable a dynamic datatype.

        Null aware compound assignment operator (??=)

            String? lastName;
            lastName ??= 'Bar';
            // Assign the value of the LHS to the variable only if the variable is nullable.

        Null Aware Operator (?)
            To access the properties of optional variables

            String? nullName;
            print(nullName ?? 'Foo'); // 'Foo'.

        Nullable Collections

            List<String>? names; // could either be null or contain a list of strings.

            List<String?>? names; // could be null or contain a list of nullable strings.

4/1/2023
	NOTES:

        Late Keyword (late)
            Late variables are initialized when they are first used
            ===============================
            void main(){
                print('Before');
                late String name = provideName();
                print('After');
                print('name')
            }

            String provideName(){
                print('Function is called');
                return 'Foo Bar'
            }

            Output:
            >> Before
            >> After
            >> Function is called
            >> Foo Bar
            ===============================

            Late final will be initialized when they are used and can not be reaasigned.

4/2/2023
	NOTES:

        Functions
            Endeavour to specify the return type of your functions.

            If no specified return type, the function type is null (dynamic)

        Named Parameter ({Keyword name})

            void main(List<String> args) {
                sayHelloTo();
                sayHelloTo(name: null);
                sayHelloTo(name: 'Foo');
                }

            void sayHelloTo({String? name}) {
                print('Hello, $name!');
                }

            Named parameters must have a default value or be optional.

        Required Named Parameters (required)

            Use keyword 'required' to ensure a parameter is given a value in the callsite.

            Required named  parameters can be optional but cannot have a defailt value.

        Positional arguments

          *  They are passed in order.
          *  They don't have names associated with them at callsite.
          *  They are always required.
          *  They can't have default values

        Optional positional parameters ([])
             ===========================

             void main(List<String> args) {
                makeUpperCase();
                makeUpperCase(null);
                makeUpperCase('Foo');
                makeUpperCase('Foo', 'Bar');
                 // makeUpperCase('Foo', null);
                makeUpperCase(null, 'Bar');
                }

            void makeUpperCase([
                String? name,
                String lastName = 'Bar',
                ]) {
                print(name?.toUpperCase());
                print(lastName.toUpperCase());
                }
            ============================
        












	
	

            

